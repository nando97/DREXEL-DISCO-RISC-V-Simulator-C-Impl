main: addi x9, x0, 16            // x5 is the idx of the array
arrLoop: beq x9, x0, exitArrLoop // stop loop when x5 = 0 to prevent neg idx 
addi x9, x9, -1                  // decrement array idx by 1
slli x5, x9, 3                   // multiply x9 by 8 to get next mem address
sd x9, 0(x5)                     // value is equal to array idx, so store array idx
jal x0, arrLoop                  // jump back to array loop
exitArrLoop: addi x10, x9, 0     // first arg for matrix_op is the matrix addr 
addi x18, x0, 16                 // make pointer for out array
addi x11, x18, 0                 // sec arg for matrx_op is out address
jal x1, matrix_opr               // jump to matrix_op with matrix and out as input
jal x0, endProg                  // after matrix_op, the program is complete
shift: sll x10, x10, x11         // shift function shifts its 1st arg by its 2nd arg
jalr x0, 0(x1)                   // return to caller with result in x10 
matrix_opr: addi sp, sp, -64     // allocate space on stack for saved regs
sd x1, 56(sp)
sd x23, 48(sp)
sd x22, 40(sp)
sd x21, 32(sp)
sd x20, 24(sp)
sd x19, 16(sp)
sd x18, 8(sp)
sd x9, 0(sp)
addi x9, x10, 0                  // x9 = matrix addr
addi x18, x11, 0                 // x18 = out addr
addi x19, x0, 0                  // i=0
addi x20, x0, 4                  // max iter
for1test: beq x19, x20, exit1    // branch to exit1 if i >= 4
slli x21, x19, 3                 // x21 = i*8
add x21, x21, x18                // x21 = out + (i*8) 
addi x22, x0, 0                  // x22 placeholder for out[i]
addi x23, x0, 0                  // j = 0
for2test: beq x23, x20, exit2    // branch to exit2 if j >= 4 
slli x5, x19, 2                  // x5 = i*4 
add x5, x5, x23                  // x5 = (i*4) + j
add x5, x5, x9                   // x5 = mat + (i*4) + j
ld x10, 0(x5)                    // x10 = mat[i*4 + j]
addi x11, x19, 0                 // x11 = i
jal x1, shift                    // pass x10(mat) and x11(shift) to shift
add x22, x22, x10                // x22 = x22 + result of shift
addi x23, x23, 1                 // j++ 
jal x0, for2test                 // go back to inner loop
exit2: sd x22, 0(x21)            // store result of inner loop 
addi x19, x19, 1                 // increment i before return to outer loop
jal x0, for1test                 // return to outer loop
exit1: ld x9, 0(sp)              // restore stored regs
ld x18, 8(sp)
ld x19, 16(sp)
ld x20, 24(sp)
ld x21, 32(sp)
ld x22, 40(sp)
ld x23, 48(sp)
ld x1, 56(sp)
addi sp, sp, 64 
jalr x0, 0(x1)                  // finished matrix_opr; return to caller
endProg: addi x0, x0, 0         // finished program; do nothing